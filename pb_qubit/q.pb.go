// Code generated by protoc-gen-go. DO NOT EDIT.
// source: q.proto

/*
Package pb_qubit is a generated protocol buffer package.

It is generated from these files:
	q.proto

It has these top-level messages:
	Q
	QsimRequest
	ApplyRequest
	ControlledRequest
	QsimResponse
	Qubit
	Empty
	NumberOfBitResponse
	EpsRequest
	BoolResponse
	DoubleResponse
	QRequest
	QResponse
	Complex128Response
	MatrixRequest
	MatrixResponse
	EqualsRequest
	AmplitudeResponse
	ProbabilityResponse
	MeasureRequest
	BitRequest
	ProbabilityAtResponse
*/
package pb_qubit

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import math1 "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Q struct {
	Qubit *Qubit `protobuf:"bytes,1,opt,name=qubit" json:"qubit,omitempty"`
}

func (m *Q) Reset()                    { *m = Q{} }
func (m *Q) String() string            { return proto.CompactTextString(m) }
func (*Q) ProtoMessage()               {}
func (*Q) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Q) GetQubit() *Qubit {
	if m != nil {
		return m.Qubit
	}
	return nil
}

type QsimRequest struct {
	Q []*Q `protobuf:"bytes,1,rep,name=q" json:"q,omitempty"`
}

func (m *QsimRequest) Reset()                    { *m = QsimRequest{} }
func (m *QsimRequest) String() string            { return proto.CompactTextString(m) }
func (*QsimRequest) ProtoMessage()               {}
func (*QsimRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *QsimRequest) GetQ() []*Q {
	if m != nil {
		return m.Q
	}
	return nil
}

type ApplyRequest struct {
	M *math1.Matrix `protobuf:"bytes,1,opt,name=m" json:"m,omitempty"`
	Q []*Q          `protobuf:"bytes,2,rep,name=q" json:"q,omitempty"`
}

func (m *ApplyRequest) Reset()                    { *m = ApplyRequest{} }
func (m *ApplyRequest) String() string            { return proto.CompactTextString(m) }
func (*ApplyRequest) ProtoMessage()               {}
func (*ApplyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ApplyRequest) GetM() *math1.Matrix {
	if m != nil {
		return m.M
	}
	return nil
}

func (m *ApplyRequest) GetQ() []*Q {
	if m != nil {
		return m.Q
	}
	return nil
}

type ControlledRequest struct {
	Control []*Q  `protobuf:"bytes,1,rep,name=control" json:"control,omitempty"`
	Target  *Q    `protobuf:"bytes,2,opt,name=target" json:"target,omitempty"`
	K       int64 `protobuf:"varint,3,opt,name=k" json:"k,omitempty"`
}

func (m *ControlledRequest) Reset()                    { *m = ControlledRequest{} }
func (m *ControlledRequest) String() string            { return proto.CompactTextString(m) }
func (*ControlledRequest) ProtoMessage()               {}
func (*ControlledRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ControlledRequest) GetControl() []*Q {
	if m != nil {
		return m.Control
	}
	return nil
}

func (m *ControlledRequest) GetTarget() *Q {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *ControlledRequest) GetK() int64 {
	if m != nil {
		return m.K
	}
	return 0
}

type QsimResponse struct {
	Q *Q `protobuf:"bytes,1,opt,name=q" json:"q,omitempty"`
}

func (m *QsimResponse) Reset()                    { *m = QsimResponse{} }
func (m *QsimResponse) String() string            { return proto.CompactTextString(m) }
func (*QsimResponse) ProtoMessage()               {}
func (*QsimResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *QsimResponse) GetQ() *Q {
	if m != nil {
		return m.Q
	}
	return nil
}

type Qubit struct {
	Vector *math1.Vector `protobuf:"bytes,1,opt,name=vector" json:"vector,omitempty"`
}

func (m *Qubit) Reset()                    { *m = Qubit{} }
func (m *Qubit) String() string            { return proto.CompactTextString(m) }
func (*Qubit) ProtoMessage()               {}
func (*Qubit) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Qubit) GetVector() *math1.Vector {
	if m != nil {
		return m.Vector
	}
	return nil
}

// None is empty request
type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type NumberOfBitResponse struct {
	Bit int32 `protobuf:"varint,1,opt,name=bit" json:"bit,omitempty"`
}

func (m *NumberOfBitResponse) Reset()                    { *m = NumberOfBitResponse{} }
func (m *NumberOfBitResponse) String() string            { return proto.CompactTextString(m) }
func (*NumberOfBitResponse) ProtoMessage()               {}
func (*NumberOfBitResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *NumberOfBitResponse) GetBit() int32 {
	if m != nil {
		return m.Bit
	}
	return 0
}

type EpsRequest struct {
	Eps []float64 `protobuf:"fixed64,1,rep,packed,name=eps" json:"eps,omitempty"`
}

func (m *EpsRequest) Reset()                    { *m = EpsRequest{} }
func (m *EpsRequest) String() string            { return proto.CompactTextString(m) }
func (*EpsRequest) ProtoMessage()               {}
func (*EpsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *EpsRequest) GetEps() []float64 {
	if m != nil {
		return m.Eps
	}
	return nil
}

type BoolResponse struct {
	Ok bool `protobuf:"varint,1,opt,name=ok" json:"ok,omitempty"`
}

func (m *BoolResponse) Reset()                    { *m = BoolResponse{} }
func (m *BoolResponse) String() string            { return proto.CompactTextString(m) }
func (*BoolResponse) ProtoMessage()               {}
func (*BoolResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *BoolResponse) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

type DoubleResponse struct {
	Data float64 `protobuf:"fixed64,1,opt,name=data" json:"data,omitempty"`
}

func (m *DoubleResponse) Reset()                    { *m = DoubleResponse{} }
func (m *DoubleResponse) String() string            { return proto.CompactTextString(m) }
func (*DoubleResponse) ProtoMessage()               {}
func (*DoubleResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *DoubleResponse) GetData() float64 {
	if m != nil {
		return m.Data
	}
	return 0
}

type QRequest struct {
	Qubit *Qubit `protobuf:"bytes,1,opt,name=qubit" json:"qubit,omitempty"`
}

func (m *QRequest) Reset()                    { *m = QRequest{} }
func (m *QRequest) String() string            { return proto.CompactTextString(m) }
func (*QRequest) ProtoMessage()               {}
func (*QRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *QRequest) GetQubit() *Qubit {
	if m != nil {
		return m.Qubit
	}
	return nil
}

type QResponse struct {
	Qubit *Qubit `protobuf:"bytes,1,opt,name=qubit" json:"qubit,omitempty"`
}

func (m *QResponse) Reset()                    { *m = QResponse{} }
func (m *QResponse) String() string            { return proto.CompactTextString(m) }
func (*QResponse) ProtoMessage()               {}
func (*QResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *QResponse) GetQubit() *Qubit {
	if m != nil {
		return m.Qubit
	}
	return nil
}

type Complex128Response struct {
	Complex *math1.Complex128 `protobuf:"bytes,1,opt,name=complex" json:"complex,omitempty"`
}

func (m *Complex128Response) Reset()                    { *m = Complex128Response{} }
func (m *Complex128Response) String() string            { return proto.CompactTextString(m) }
func (*Complex128Response) ProtoMessage()               {}
func (*Complex128Response) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Complex128Response) GetComplex() *math1.Complex128 {
	if m != nil {
		return m.Complex
	}
	return nil
}

type MatrixRequest struct {
	Matrix *math1.Matrix `protobuf:"bytes,1,opt,name=matrix" json:"matrix,omitempty"`
}

func (m *MatrixRequest) Reset()                    { *m = MatrixRequest{} }
func (m *MatrixRequest) String() string            { return proto.CompactTextString(m) }
func (*MatrixRequest) ProtoMessage()               {}
func (*MatrixRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *MatrixRequest) GetMatrix() *math1.Matrix {
	if m != nil {
		return m.Matrix
	}
	return nil
}

type MatrixResponse struct {
	Matrix *math1.Matrix `protobuf:"bytes,1,opt,name=matrix" json:"matrix,omitempty"`
}

func (m *MatrixResponse) Reset()                    { *m = MatrixResponse{} }
func (m *MatrixResponse) String() string            { return proto.CompactTextString(m) }
func (*MatrixResponse) ProtoMessage()               {}
func (*MatrixResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *MatrixResponse) GetMatrix() *math1.Matrix {
	if m != nil {
		return m.Matrix
	}
	return nil
}

type EqualsRequest struct {
	Qubit *Qubit    `protobuf:"bytes,1,opt,name=qubit" json:"qubit,omitempty"`
	Eps   []float64 `protobuf:"fixed64,2,rep,packed,name=eps" json:"eps,omitempty"`
}

func (m *EqualsRequest) Reset()                    { *m = EqualsRequest{} }
func (m *EqualsRequest) String() string            { return proto.CompactTextString(m) }
func (*EqualsRequest) ProtoMessage()               {}
func (*EqualsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *EqualsRequest) GetQubit() *Qubit {
	if m != nil {
		return m.Qubit
	}
	return nil
}

func (m *EqualsRequest) GetEps() []float64 {
	if m != nil {
		return m.Eps
	}
	return nil
}

type AmplitudeResponse struct {
	Complex []*math1.Complex128 `protobuf:"bytes,1,rep,name=complex" json:"complex,omitempty"`
}

func (m *AmplitudeResponse) Reset()                    { *m = AmplitudeResponse{} }
func (m *AmplitudeResponse) String() string            { return proto.CompactTextString(m) }
func (*AmplitudeResponse) ProtoMessage()               {}
func (*AmplitudeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *AmplitudeResponse) GetComplex() []*math1.Complex128 {
	if m != nil {
		return m.Complex
	}
	return nil
}

type ProbabilityResponse struct {
	Data []float64 `protobuf:"fixed64,1,rep,packed,name=data" json:"data,omitempty"`
}

func (m *ProbabilityResponse) Reset()                    { *m = ProbabilityResponse{} }
func (m *ProbabilityResponse) String() string            { return proto.CompactTextString(m) }
func (*ProbabilityResponse) ProtoMessage()               {}
func (*ProbabilityResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *ProbabilityResponse) GetData() []float64 {
	if m != nil {
		return m.Data
	}
	return nil
}

type MeasureRequest struct {
	Bit []int32 `protobuf:"varint,1,rep,packed,name=bit" json:"bit,omitempty"`
}

func (m *MeasureRequest) Reset()                    { *m = MeasureRequest{} }
func (m *MeasureRequest) String() string            { return proto.CompactTextString(m) }
func (*MeasureRequest) ProtoMessage()               {}
func (*MeasureRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *MeasureRequest) GetBit() []int32 {
	if m != nil {
		return m.Bit
	}
	return nil
}

type BitRequest struct {
	Bit int32 `protobuf:"varint,1,opt,name=bit" json:"bit,omitempty"`
}

func (m *BitRequest) Reset()                    { *m = BitRequest{} }
func (m *BitRequest) String() string            { return proto.CompactTextString(m) }
func (*BitRequest) ProtoMessage()               {}
func (*BitRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *BitRequest) GetBit() int32 {
	if m != nil {
		return m.Bit
	}
	return 0
}

type ProbabilityAtResponse struct {
	I []int32   `protobuf:"varint,1,rep,packed,name=i" json:"i,omitempty"`
	D []float64 `protobuf:"fixed64,2,rep,packed,name=d" json:"d,omitempty"`
}

func (m *ProbabilityAtResponse) Reset()                    { *m = ProbabilityAtResponse{} }
func (m *ProbabilityAtResponse) String() string            { return proto.CompactTextString(m) }
func (*ProbabilityAtResponse) ProtoMessage()               {}
func (*ProbabilityAtResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *ProbabilityAtResponse) GetI() []int32 {
	if m != nil {
		return m.I
	}
	return nil
}

func (m *ProbabilityAtResponse) GetD() []float64 {
	if m != nil {
		return m.D
	}
	return nil
}

func init() {
	proto.RegisterType((*Q)(nil), "pb_qubit.Q")
	proto.RegisterType((*QsimRequest)(nil), "pb_qubit.QsimRequest")
	proto.RegisterType((*ApplyRequest)(nil), "pb_qubit.ApplyRequest")
	proto.RegisterType((*ControlledRequest)(nil), "pb_qubit.ControlledRequest")
	proto.RegisterType((*QsimResponse)(nil), "pb_qubit.QsimResponse")
	proto.RegisterType((*Qubit)(nil), "pb_qubit.Qubit")
	proto.RegisterType((*Empty)(nil), "pb_qubit.Empty")
	proto.RegisterType((*NumberOfBitResponse)(nil), "pb_qubit.NumberOfBitResponse")
	proto.RegisterType((*EpsRequest)(nil), "pb_qubit.EpsRequest")
	proto.RegisterType((*BoolResponse)(nil), "pb_qubit.BoolResponse")
	proto.RegisterType((*DoubleResponse)(nil), "pb_qubit.DoubleResponse")
	proto.RegisterType((*QRequest)(nil), "pb_qubit.QRequest")
	proto.RegisterType((*QResponse)(nil), "pb_qubit.QResponse")
	proto.RegisterType((*Complex128Response)(nil), "pb_qubit.Complex128Response")
	proto.RegisterType((*MatrixRequest)(nil), "pb_qubit.MatrixRequest")
	proto.RegisterType((*MatrixResponse)(nil), "pb_qubit.MatrixResponse")
	proto.RegisterType((*EqualsRequest)(nil), "pb_qubit.EqualsRequest")
	proto.RegisterType((*AmplitudeResponse)(nil), "pb_qubit.AmplitudeResponse")
	proto.RegisterType((*ProbabilityResponse)(nil), "pb_qubit.ProbabilityResponse")
	proto.RegisterType((*MeasureRequest)(nil), "pb_qubit.MeasureRequest")
	proto.RegisterType((*BitRequest)(nil), "pb_qubit.BitRequest")
	proto.RegisterType((*ProbabilityAtResponse)(nil), "pb_qubit.ProbabilityAtResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Qsim service

type QsimClient interface {
	H(ctx context.Context, in *QsimRequest, opts ...grpc.CallOption) (*QsimResponse, error)
	X(ctx context.Context, in *QsimRequest, opts ...grpc.CallOption) (*QsimResponse, error)
	Y(ctx context.Context, in *QsimRequest, opts ...grpc.CallOption) (*QsimResponse, error)
	Z(ctx context.Context, in *QsimRequest, opts ...grpc.CallOption) (*QsimResponse, error)
	S(ctx context.Context, in *QsimRequest, opts ...grpc.CallOption) (*QsimResponse, error)
	T(ctx context.Context, in *QsimRequest, opts ...grpc.CallOption) (*QsimResponse, error)
	Apply(ctx context.Context, in *ApplyRequest, opts ...grpc.CallOption) (*QsimResponse, error)
	ControlledR(ctx context.Context, in *ControlledRequest, opts ...grpc.CallOption) (*QsimResponse, error)
	ControlledZ(ctx context.Context, in *ControlledRequest, opts ...grpc.CallOption) (*QsimResponse, error)
	ControlledNOT(ctx context.Context, in *ControlledRequest, opts ...grpc.CallOption) (*QsimResponse, error)
	QFT(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QsimResponse, error)
	InverseQFT(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QsimResponse, error)
}

type qsimClient struct {
	cc *grpc.ClientConn
}

func NewQsimClient(cc *grpc.ClientConn) QsimClient {
	return &qsimClient{cc}
}

func (c *qsimClient) H(ctx context.Context, in *QsimRequest, opts ...grpc.CallOption) (*QsimResponse, error) {
	out := new(QsimResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.Qsim/H", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qsimClient) X(ctx context.Context, in *QsimRequest, opts ...grpc.CallOption) (*QsimResponse, error) {
	out := new(QsimResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.Qsim/X", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qsimClient) Y(ctx context.Context, in *QsimRequest, opts ...grpc.CallOption) (*QsimResponse, error) {
	out := new(QsimResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.Qsim/Y", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qsimClient) Z(ctx context.Context, in *QsimRequest, opts ...grpc.CallOption) (*QsimResponse, error) {
	out := new(QsimResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.Qsim/Z", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qsimClient) S(ctx context.Context, in *QsimRequest, opts ...grpc.CallOption) (*QsimResponse, error) {
	out := new(QsimResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.Qsim/S", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qsimClient) T(ctx context.Context, in *QsimRequest, opts ...grpc.CallOption) (*QsimResponse, error) {
	out := new(QsimResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.Qsim/T", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qsimClient) Apply(ctx context.Context, in *ApplyRequest, opts ...grpc.CallOption) (*QsimResponse, error) {
	out := new(QsimResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.Qsim/Apply", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qsimClient) ControlledR(ctx context.Context, in *ControlledRequest, opts ...grpc.CallOption) (*QsimResponse, error) {
	out := new(QsimResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.Qsim/ControlledR", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qsimClient) ControlledZ(ctx context.Context, in *ControlledRequest, opts ...grpc.CallOption) (*QsimResponse, error) {
	out := new(QsimResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.Qsim/ControlledZ", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qsimClient) ControlledNOT(ctx context.Context, in *ControlledRequest, opts ...grpc.CallOption) (*QsimResponse, error) {
	out := new(QsimResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.Qsim/ControlledNOT", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qsimClient) QFT(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QsimResponse, error) {
	out := new(QsimResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.Qsim/QFT", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qsimClient) InverseQFT(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QsimResponse, error) {
	out := new(QsimResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.Qsim/InverseQFT", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Qsim service

type QsimServer interface {
	H(context.Context, *QsimRequest) (*QsimResponse, error)
	X(context.Context, *QsimRequest) (*QsimResponse, error)
	Y(context.Context, *QsimRequest) (*QsimResponse, error)
	Z(context.Context, *QsimRequest) (*QsimResponse, error)
	S(context.Context, *QsimRequest) (*QsimResponse, error)
	T(context.Context, *QsimRequest) (*QsimResponse, error)
	Apply(context.Context, *ApplyRequest) (*QsimResponse, error)
	ControlledR(context.Context, *ControlledRequest) (*QsimResponse, error)
	ControlledZ(context.Context, *ControlledRequest) (*QsimResponse, error)
	ControlledNOT(context.Context, *ControlledRequest) (*QsimResponse, error)
	QFT(context.Context, *Empty) (*QsimResponse, error)
	InverseQFT(context.Context, *Empty) (*QsimResponse, error)
}

func RegisterQsimServer(s *grpc.Server, srv QsimServer) {
	s.RegisterService(&_Qsim_serviceDesc, srv)
}

func _Qsim_H_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QsimRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QsimServer).H(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.Qsim/H",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QsimServer).H(ctx, req.(*QsimRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Qsim_X_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QsimRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QsimServer).X(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.Qsim/X",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QsimServer).X(ctx, req.(*QsimRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Qsim_Y_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QsimRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QsimServer).Y(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.Qsim/Y",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QsimServer).Y(ctx, req.(*QsimRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Qsim_Z_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QsimRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QsimServer).Z(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.Qsim/Z",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QsimServer).Z(ctx, req.(*QsimRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Qsim_S_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QsimRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QsimServer).S(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.Qsim/S",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QsimServer).S(ctx, req.(*QsimRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Qsim_T_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QsimRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QsimServer).T(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.Qsim/T",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QsimServer).T(ctx, req.(*QsimRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Qsim_Apply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QsimServer).Apply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.Qsim/Apply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QsimServer).Apply(ctx, req.(*ApplyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Qsim_ControlledR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ControlledRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QsimServer).ControlledR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.Qsim/ControlledR",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QsimServer).ControlledR(ctx, req.(*ControlledRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Qsim_ControlledZ_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ControlledRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QsimServer).ControlledZ(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.Qsim/ControlledZ",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QsimServer).ControlledZ(ctx, req.(*ControlledRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Qsim_ControlledNOT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ControlledRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QsimServer).ControlledNOT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.Qsim/ControlledNOT",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QsimServer).ControlledNOT(ctx, req.(*ControlledRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Qsim_QFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QsimServer).QFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.Qsim/QFT",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QsimServer).QFT(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Qsim_InverseQFT_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QsimServer).InverseQFT(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.Qsim/InverseQFT",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QsimServer).InverseQFT(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _Qsim_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb_qubit.Qsim",
	HandlerType: (*QsimServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "H",
			Handler:    _Qsim_H_Handler,
		},
		{
			MethodName: "X",
			Handler:    _Qsim_X_Handler,
		},
		{
			MethodName: "Y",
			Handler:    _Qsim_Y_Handler,
		},
		{
			MethodName: "Z",
			Handler:    _Qsim_Z_Handler,
		},
		{
			MethodName: "S",
			Handler:    _Qsim_S_Handler,
		},
		{
			MethodName: "T",
			Handler:    _Qsim_T_Handler,
		},
		{
			MethodName: "Apply",
			Handler:    _Qsim_Apply_Handler,
		},
		{
			MethodName: "ControlledR",
			Handler:    _Qsim_ControlledR_Handler,
		},
		{
			MethodName: "ControlledZ",
			Handler:    _Qsim_ControlledZ_Handler,
		},
		{
			MethodName: "ControlledNOT",
			Handler:    _Qsim_ControlledNOT_Handler,
		},
		{
			MethodName: "QFT",
			Handler:    _Qsim_QFT_Handler,
		},
		{
			MethodName: "InverseQFT",
			Handler:    _Qsim_InverseQFT_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "q.proto",
}

// Client API for QQubit service

type QQubitClient interface {
	NumberOfBit(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NumberOfBitResponse, error)
	IsZero(ctx context.Context, in *EpsRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	IsOne(ctx context.Context, in *EpsRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	InnerProduct(ctx context.Context, in *QRequest, opts ...grpc.CallOption) (*Complex128Response, error)
	OuterProduct(ctx context.Context, in *QRequest, opts ...grpc.CallOption) (*MatrixResponse, error)
	Fidelity(ctx context.Context, in *QRequest, opts ...grpc.CallOption) (*DoubleResponse, error)
	TraceDistance(ctx context.Context, in *QRequest, opts ...grpc.CallOption) (*DoubleResponse, error)
	Equals(ctx context.Context, in *EqualsRequest, opts ...grpc.CallOption) (*BoolResponse, error)
	TensorProduct(ctx context.Context, in *QRequest, opts ...grpc.CallOption) (*QResponse, error)
	Apply(ctx context.Context, in *MatrixRequest, opts ...grpc.CallOption) (*QResponse, error)
	Normalize(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QResponse, error)
	Amplitude(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AmplitudeResponse, error)
	Probability(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ProbabilityResponse, error)
	Measure(ctx context.Context, in *MeasureRequest, opts ...grpc.CallOption) (*QResponse, error)
	ProbabilityZeroAt(ctx context.Context, in *BitRequest, opts ...grpc.CallOption) (*ProbabilityAtResponse, error)
	ProbabilityOneAt(ctx context.Context, in *BitRequest, opts ...grpc.CallOption) (*ProbabilityAtResponse, error)
	MeasureAt(ctx context.Context, in *BitRequest, opts ...grpc.CallOption) (*QResponse, error)
}

type qQubitClient struct {
	cc *grpc.ClientConn
}

func NewQQubitClient(cc *grpc.ClientConn) QQubitClient {
	return &qQubitClient{cc}
}

func (c *qQubitClient) NumberOfBit(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NumberOfBitResponse, error) {
	out := new(NumberOfBitResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.QQubit/NumberOfBit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qQubitClient) IsZero(ctx context.Context, in *EpsRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	out := new(BoolResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.QQubit/IsZero", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qQubitClient) IsOne(ctx context.Context, in *EpsRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	out := new(BoolResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.QQubit/IsOne", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qQubitClient) InnerProduct(ctx context.Context, in *QRequest, opts ...grpc.CallOption) (*Complex128Response, error) {
	out := new(Complex128Response)
	err := grpc.Invoke(ctx, "/pb_qubit.QQubit/InnerProduct", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qQubitClient) OuterProduct(ctx context.Context, in *QRequest, opts ...grpc.CallOption) (*MatrixResponse, error) {
	out := new(MatrixResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.QQubit/OuterProduct", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qQubitClient) Fidelity(ctx context.Context, in *QRequest, opts ...grpc.CallOption) (*DoubleResponse, error) {
	out := new(DoubleResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.QQubit/Fidelity", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qQubitClient) TraceDistance(ctx context.Context, in *QRequest, opts ...grpc.CallOption) (*DoubleResponse, error) {
	out := new(DoubleResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.QQubit/TraceDistance", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qQubitClient) Equals(ctx context.Context, in *EqualsRequest, opts ...grpc.CallOption) (*BoolResponse, error) {
	out := new(BoolResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.QQubit/Equals", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qQubitClient) TensorProduct(ctx context.Context, in *QRequest, opts ...grpc.CallOption) (*QResponse, error) {
	out := new(QResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.QQubit/TensorProduct", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qQubitClient) Apply(ctx context.Context, in *MatrixRequest, opts ...grpc.CallOption) (*QResponse, error) {
	out := new(QResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.QQubit/Apply", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qQubitClient) Normalize(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*QResponse, error) {
	out := new(QResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.QQubit/Normalize", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qQubitClient) Amplitude(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*AmplitudeResponse, error) {
	out := new(AmplitudeResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.QQubit/Amplitude", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qQubitClient) Probability(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ProbabilityResponse, error) {
	out := new(ProbabilityResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.QQubit/Probability", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qQubitClient) Measure(ctx context.Context, in *MeasureRequest, opts ...grpc.CallOption) (*QResponse, error) {
	out := new(QResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.QQubit/Measure", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qQubitClient) ProbabilityZeroAt(ctx context.Context, in *BitRequest, opts ...grpc.CallOption) (*ProbabilityAtResponse, error) {
	out := new(ProbabilityAtResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.QQubit/ProbabilityZeroAt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qQubitClient) ProbabilityOneAt(ctx context.Context, in *BitRequest, opts ...grpc.CallOption) (*ProbabilityAtResponse, error) {
	out := new(ProbabilityAtResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.QQubit/ProbabilityOneAt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qQubitClient) MeasureAt(ctx context.Context, in *BitRequest, opts ...grpc.CallOption) (*QResponse, error) {
	out := new(QResponse)
	err := grpc.Invoke(ctx, "/pb_qubit.QQubit/MeasureAt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for QQubit service

type QQubitServer interface {
	NumberOfBit(context.Context, *Empty) (*NumberOfBitResponse, error)
	IsZero(context.Context, *EpsRequest) (*BoolResponse, error)
	IsOne(context.Context, *EpsRequest) (*BoolResponse, error)
	InnerProduct(context.Context, *QRequest) (*Complex128Response, error)
	OuterProduct(context.Context, *QRequest) (*MatrixResponse, error)
	Fidelity(context.Context, *QRequest) (*DoubleResponse, error)
	TraceDistance(context.Context, *QRequest) (*DoubleResponse, error)
	Equals(context.Context, *EqualsRequest) (*BoolResponse, error)
	TensorProduct(context.Context, *QRequest) (*QResponse, error)
	Apply(context.Context, *MatrixRequest) (*QResponse, error)
	Normalize(context.Context, *Empty) (*QResponse, error)
	Amplitude(context.Context, *Empty) (*AmplitudeResponse, error)
	Probability(context.Context, *Empty) (*ProbabilityResponse, error)
	Measure(context.Context, *MeasureRequest) (*QResponse, error)
	ProbabilityZeroAt(context.Context, *BitRequest) (*ProbabilityAtResponse, error)
	ProbabilityOneAt(context.Context, *BitRequest) (*ProbabilityAtResponse, error)
	MeasureAt(context.Context, *BitRequest) (*QResponse, error)
}

func RegisterQQubitServer(s *grpc.Server, srv QQubitServer) {
	s.RegisterService(&_QQubit_serviceDesc, srv)
}

func _QQubit_NumberOfBit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QQubitServer).NumberOfBit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.QQubit/NumberOfBit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QQubitServer).NumberOfBit(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _QQubit_IsZero_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EpsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QQubitServer).IsZero(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.QQubit/IsZero",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QQubitServer).IsZero(ctx, req.(*EpsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QQubit_IsOne_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EpsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QQubitServer).IsOne(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.QQubit/IsOne",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QQubitServer).IsOne(ctx, req.(*EpsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QQubit_InnerProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QQubitServer).InnerProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.QQubit/InnerProduct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QQubitServer).InnerProduct(ctx, req.(*QRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QQubit_OuterProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QQubitServer).OuterProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.QQubit/OuterProduct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QQubitServer).OuterProduct(ctx, req.(*QRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QQubit_Fidelity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QQubitServer).Fidelity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.QQubit/Fidelity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QQubitServer).Fidelity(ctx, req.(*QRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QQubit_TraceDistance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QQubitServer).TraceDistance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.QQubit/TraceDistance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QQubitServer).TraceDistance(ctx, req.(*QRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QQubit_Equals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EqualsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QQubitServer).Equals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.QQubit/Equals",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QQubitServer).Equals(ctx, req.(*EqualsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QQubit_TensorProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QQubitServer).TensorProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.QQubit/TensorProduct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QQubitServer).TensorProduct(ctx, req.(*QRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QQubit_Apply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MatrixRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QQubitServer).Apply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.QQubit/Apply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QQubitServer).Apply(ctx, req.(*MatrixRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QQubit_Normalize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QQubitServer).Normalize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.QQubit/Normalize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QQubitServer).Normalize(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _QQubit_Amplitude_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QQubitServer).Amplitude(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.QQubit/Amplitude",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QQubitServer).Amplitude(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _QQubit_Probability_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QQubitServer).Probability(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.QQubit/Probability",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QQubitServer).Probability(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _QQubit_Measure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MeasureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QQubitServer).Measure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.QQubit/Measure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QQubitServer).Measure(ctx, req.(*MeasureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QQubit_ProbabilityZeroAt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QQubitServer).ProbabilityZeroAt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.QQubit/ProbabilityZeroAt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QQubitServer).ProbabilityZeroAt(ctx, req.(*BitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QQubit_ProbabilityOneAt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QQubitServer).ProbabilityOneAt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.QQubit/ProbabilityOneAt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QQubitServer).ProbabilityOneAt(ctx, req.(*BitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QQubit_MeasureAt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QQubitServer).MeasureAt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb_qubit.QQubit/MeasureAt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QQubitServer).MeasureAt(ctx, req.(*BitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _QQubit_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb_qubit.QQubit",
	HandlerType: (*QQubitServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NumberOfBit",
			Handler:    _QQubit_NumberOfBit_Handler,
		},
		{
			MethodName: "IsZero",
			Handler:    _QQubit_IsZero_Handler,
		},
		{
			MethodName: "IsOne",
			Handler:    _QQubit_IsOne_Handler,
		},
		{
			MethodName: "InnerProduct",
			Handler:    _QQubit_InnerProduct_Handler,
		},
		{
			MethodName: "OuterProduct",
			Handler:    _QQubit_OuterProduct_Handler,
		},
		{
			MethodName: "Fidelity",
			Handler:    _QQubit_Fidelity_Handler,
		},
		{
			MethodName: "TraceDistance",
			Handler:    _QQubit_TraceDistance_Handler,
		},
		{
			MethodName: "Equals",
			Handler:    _QQubit_Equals_Handler,
		},
		{
			MethodName: "TensorProduct",
			Handler:    _QQubit_TensorProduct_Handler,
		},
		{
			MethodName: "Apply",
			Handler:    _QQubit_Apply_Handler,
		},
		{
			MethodName: "Normalize",
			Handler:    _QQubit_Normalize_Handler,
		},
		{
			MethodName: "Amplitude",
			Handler:    _QQubit_Amplitude_Handler,
		},
		{
			MethodName: "Probability",
			Handler:    _QQubit_Probability_Handler,
		},
		{
			MethodName: "Measure",
			Handler:    _QQubit_Measure_Handler,
		},
		{
			MethodName: "ProbabilityZeroAt",
			Handler:    _QQubit_ProbabilityZeroAt_Handler,
		},
		{
			MethodName: "ProbabilityOneAt",
			Handler:    _QQubit_ProbabilityOneAt_Handler,
		},
		{
			MethodName: "MeasureAt",
			Handler:    _QQubit_MeasureAt_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "q.proto",
}

func init() { proto.RegisterFile("q.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 889 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0x6d, 0x73, 0xdb, 0x44,
	0x10, 0xf6, 0x59, 0xb1, 0xe3, 0xac, 0xe5, 0x34, 0xb9, 0x50, 0x6a, 0x52, 0x28, 0x99, 0x23, 0x1d,
	0xd2, 0xce, 0xe0, 0x52, 0xa7, 0x40, 0x68, 0x67, 0x08, 0x76, 0x93, 0x4c, 0x3d, 0xd0, 0x38, 0x16,
	0x1e, 0x06, 0xf2, 0x85, 0x91, 0xec, 0xa3, 0xd1, 0x58, 0xd2, 0xc9, 0xd2, 0xa9, 0xd3, 0xe4, 0x6f,
	0xf1, 0x17, 0xf8, 0x61, 0x8c, 0x4e, 0x6f, 0xe7, 0x58, 0x11, 0xb6, 0xfb, 0xc5, 0xa3, 0xec, 0xee,
	0xf3, 0xdc, 0xed, 0xcb, 0x3d, 0x1b, 0x58, 0x9f, 0xb6, 0x5c, 0x8f, 0x71, 0x86, 0x6b, 0xae, 0xf1,
	0xd7, 0x34, 0x30, 0x4c, 0xbe, 0x7b, 0xcf, 0xd6, 0xf9, 0xd5, 0xb3, 0xf0, 0x27, 0x72, 0x91, 0xa7,
	0x80, 0x06, 0xf8, 0x31, 0x54, 0x84, 0xbb, 0x89, 0xf6, 0xd0, 0x41, 0xbd, 0x7d, 0xaf, 0x95, 0xc4,
	0xb7, 0x06, 0xe1, 0xaf, 0x16, 0x79, 0xc9, 0x01, 0xd4, 0x07, 0xbe, 0x69, 0x6b, 0x74, 0x1a, 0x50,
	0x9f, 0xe3, 0xcf, 0x00, 0x4d, 0x9b, 0x68, 0x4f, 0x39, 0xa8, 0xb7, 0xeb, 0x12, 0x42, 0x43, 0x53,
	0x72, 0x0a, 0x6a, 0xc7, 0x75, 0xad, 0xeb, 0x24, 0x74, 0x17, 0x90, 0x1d, 0x93, 0xab, 0x2d, 0x71,
	0xfa, 0x5b, 0x9d, 0x7b, 0xe6, 0x07, 0x0d, 0xd9, 0x11, 0x4d, 0x39, 0x97, 0xc6, 0x86, 0xed, 0xd7,
	0xcc, 0xe1, 0x1e, 0xb3, 0x2c, 0x3a, 0x4e, 0xb8, 0x1e, 0xc3, 0xfa, 0x28, 0x32, 0xe6, 0x1d, 0x9e,
	0xf8, 0xf0, 0x57, 0x50, 0xe5, 0xba, 0xf7, 0x8e, 0xf2, 0x66, 0x59, 0x9c, 0x3b, 0x13, 0x15, 0xbb,
	0xb0, 0x0a, 0x68, 0xd2, 0x54, 0xf6, 0xd0, 0x81, 0xa2, 0xa1, 0x09, 0x79, 0x02, 0x6a, 0x94, 0x9f,
	0xef, 0x32, 0xc7, 0xa7, 0x49, 0x82, 0x28, 0xe7, 0x66, 0xdf, 0x40, 0x45, 0x94, 0x06, 0xef, 0x43,
	0xf5, 0x3d, 0x1d, 0x71, 0xe6, 0xcd, 0xa6, 0xf7, 0xbb, 0xb0, 0x69, 0xb1, 0x8f, 0xac, 0x43, 0xe5,
	0xd4, 0x76, 0xf9, 0x35, 0xf9, 0x1a, 0x76, 0xce, 0x03, 0xdb, 0xa0, 0x5e, 0xff, 0xef, 0xae, 0xc9,
	0xd3, 0x93, 0xb6, 0x40, 0x49, 0xca, 0x5f, 0xd1, 0xc2, 0x4f, 0xf2, 0x08, 0xe0, 0xd4, 0xf5, 0x93,
	0x9c, 0xb7, 0x40, 0xa1, 0xae, 0x2f, 0xf2, 0x45, 0x5a, 0xf8, 0x49, 0x1e, 0x81, 0xda, 0x65, 0xcc,
	0x4a, 0x19, 0x36, 0xa1, 0xcc, 0x26, 0x82, 0xa0, 0xa6, 0x95, 0xd9, 0x84, 0xec, 0xc3, 0xe6, 0x09,
	0x0b, 0x0c, 0x8b, 0xa6, 0x11, 0x18, 0xd6, 0xc6, 0x3a, 0xd7, 0x45, 0x0c, 0xd2, 0xc4, 0x37, 0x79,
	0x0e, 0xb5, 0x41, 0x56, 0xd7, 0x85, 0x86, 0xa0, 0x0d, 0x1b, 0x83, 0x94, 0x73, 0x41, 0xcc, 0xcf,
	0x80, 0x5f, 0x33, 0xdb, 0xb5, 0xe8, 0x87, 0xe7, 0xed, 0xa3, 0x14, 0xfc, 0x34, 0x6c, 0xa4, 0xb0,
	0xc6, 0xf0, 0xad, 0xa8, 0x76, 0x52, 0x68, 0x12, 0x40, 0xbe, 0x83, 0x46, 0x3c, 0x31, 0xf1, 0x6d,
	0xf7, 0xa1, 0x6a, 0x0b, 0x43, 0xee, 0x58, 0xc5, 0x3e, 0xf2, 0x3d, 0x6c, 0x26, 0xb0, 0xf8, 0xd0,
	0xc5, 0x70, 0x6f, 0xa0, 0x71, 0x3a, 0x0d, 0x74, 0xcb, 0x5f, 0xae, 0x38, 0x49, 0x9f, 0xca, 0x59,
	0x9f, 0x8e, 0x61, 0xbb, 0x63, 0xbb, 0x96, 0xc9, 0x83, 0x31, 0xcd, 0xcf, 0x5c, 0x29, 0xce, 0xfc,
	0x09, 0xec, 0x5c, 0x78, 0xcc, 0xd0, 0x0d, 0xd3, 0x32, 0xf9, 0x75, 0x4e, 0x37, 0x95, 0xb4, 0x9b,
	0x04, 0x36, 0xdf, 0x52, 0xdd, 0x0f, 0x3c, 0x2a, 0xcd, 0x4d, 0x74, 0x69, 0x45, 0x9a, 0x2b, 0x31,
	0x78, 0xb7, 0xfc, 0xe9, 0xdc, 0x1d, 0xc2, 0x7d, 0xe9, 0xb8, 0x4e, 0x36, 0xa2, 0x2a, 0x20, 0x33,
	0x26, 0x42, 0x66, 0xf8, 0xd7, 0x38, 0x4e, 0x13, 0x8d, 0xdb, 0xff, 0x56, 0x60, 0x2d, 0x7c, 0x39,
	0xf8, 0x05, 0xa0, 0x37, 0xf8, 0xbe, 0x54, 0x9c, 0x4c, 0x2e, 0x76, 0x3f, 0xbd, 0x6d, 0x8e, 0x88,
	0x49, 0x29, 0x44, 0xfd, 0xb1, 0x12, 0xea, 0xcf, 0x95, 0x50, 0x97, 0x2b, 0xa1, 0x7e, 0x5b, 0x09,
	0x35, 0x5c, 0x1e, 0xf5, 0x23, 0x54, 0x84, 0x76, 0x62, 0x29, 0x44, 0x16, 0xd3, 0x02, 0xe8, 0x09,
	0xd4, 0x25, 0xbd, 0xc4, 0x0f, 0xb3, 0xc0, 0x39, 0x19, 0x5d, 0x94, 0xe5, 0x72, 0x55, 0x96, 0x33,
	0x68, 0x64, 0xe1, 0xe7, 0xfd, 0xe1, 0xaa, 0x3c, 0xdf, 0x82, 0x32, 0x38, 0x1b, 0x62, 0xe9, 0xc5,
	0x09, 0x25, 0x2d, 0x40, 0xfc, 0x00, 0xd0, 0x73, 0xde, 0x53, 0xcf, 0xa7, 0xcb, 0x01, 0xdb, 0xff,
	0xd4, 0xa0, 0x3a, 0x88, 0x64, 0xfd, 0x18, 0xea, 0x92, 0x4e, 0xcf, 0x93, 0x7c, 0x91, 0x19, 0x72,
	0xf4, 0x9c, 0x94, 0xf0, 0x11, 0x54, 0x7b, 0xfe, 0x25, 0xf5, 0x18, 0xfe, 0x44, 0xc2, 0xa6, 0x8a,
	0x2e, 0xdf, 0x42, 0xd6, 0x71, 0x71, 0xfd, 0x4a, 0xcf, 0xef, 0x3b, 0x74, 0x69, 0x60, 0x17, 0xd4,
	0x9e, 0xe3, 0x50, 0xef, 0xc2, 0x63, 0xe3, 0x60, 0xc4, 0x31, 0x96, 0x77, 0x56, 0x8c, 0xfe, 0x5c,
	0x6e, 0xc2, 0x6d, 0x45, 0x26, 0x25, 0xfc, 0x13, 0xa8, 0xfd, 0x80, 0x17, 0x73, 0x34, 0x33, 0xdb,
	0xac, 0xb8, 0x92, 0x12, 0x7e, 0x09, 0xb5, 0x33, 0x73, 0x4c, 0x43, 0xed, 0xf8, 0x3f, 0xec, 0xec,
	0x7a, 0x22, 0x25, 0x7c, 0x0c, 0x8d, 0xa1, 0xa7, 0x8f, 0xe8, 0x89, 0xe9, 0x73, 0xdd, 0x19, 0xd1,
	0xa5, 0x09, 0x5e, 0x41, 0x35, 0x52, 0x6d, 0xfc, 0x40, 0x2a, 0x9d, 0xac, 0xe3, 0x05, 0xd5, 0x7b,
	0x09, 0x8d, 0x21, 0x75, 0x7c, 0x56, 0x98, 0xfa, 0xce, 0x8c, 0x4d, 0x6e, 0x59, 0xf4, 0x64, 0x1f,
	0xcc, 0x97, 0xa6, 0x10, 0x78, 0x08, 0x1b, 0xe7, 0xcc, 0xb3, 0x75, 0xcb, 0xbc, 0xa1, 0xf3, 0x43,
	0x76, 0x07, 0xe8, 0x15, 0x6c, 0xa4, 0x2b, 0x65, 0x1e, 0x24, 0x3d, 0xb3, 0xb9, 0xc5, 0x23, 0x8a,
	0x5c, 0x97, 0xf4, 0xbd, 0x70, 0xb0, 0x73, 0xd6, 0x8e, 0xa8, 0xd3, 0x7a, 0xbc, 0x64, 0xb0, 0x3c,
	0x08, 0x33, 0x7b, 0xe7, 0xae, 0x9b, 0xff, 0x0a, 0xdb, 0x12, 0x69, 0xf8, 0x3a, 0x3a, 0x5c, 0x1e,
	0xf3, 0x6c, 0x33, 0xed, 0x7e, 0x99, 0x7b, 0x8f, 0x8e, 0xfc, 0xc4, 0x7e, 0x81, 0x2d, 0xc9, 0xd5,
	0x77, 0xe8, 0xc7, 0x90, 0x1d, 0xc1, 0x46, 0x9c, 0xc3, 0x9d, 0x2c, 0xf9, 0x49, 0x75, 0x1f, 0xc2,
	0xf6, 0x88, 0xd9, 0xad, 0x77, 0x26, 0xbf, 0x0a, 0x8c, 0x67, 0xbe, 0x7e, 0xf5, 0x82, 0xde, 0x74,
	0xd7, 0xa6, 0xbe, 0x69, 0x5f, 0x20, 0xa3, 0x2a, 0xfe, 0xcb, 0x3e, 0xfc, 0x2f, 0x00, 0x00, 0xff,
	0xff, 0x46, 0xa8, 0xa4, 0xa4, 0x8b, 0x0b, 0x00, 0x00,
}
